This is a MCP client application, meant for testing and debugging MCP StreamableHTTP servers.

Here's a comprehensive example of StreamableHTTP both from the client and server side. If necessary, Update the implementation according to the best practices described here.

MCP Server & Client with StreamableHTTP
That’s enough for the old protocol, let’s start with something new! (Hope it is still fairly new by the time you read this article!)

The Streamable HTTP!

Basic
Again, the transport uses POST and GET requests.

However, this time, we MUST provide a SINGLE HTTP endpoint path that supports both POST and GET methods. It can return an error response but we have to have it! You will see what I meant shortly!

Our server can also optionally make use of Server-Sent Events (SSE) to stream multiple server messages. This permits basic MCP servers, as well as more feature-rich servers supporting streaming and server-to-client notifications and requests.

The sequence diagram might look pretty intimidating at first, so let’s break it down with some actual code!


https://modelcontextprotocol.io/specification/2025-03-26/basic/transports#streamable-http
Minimized Server
A minimized version is always a good place to start!

However, before we can actually start on it, I have to say at the time I am writing this article, the Streamable HTTP is NOT YET AVAILABLE in the newest npm package (version 1.9.0)!

So!

Download the repository
Open tsconfig.json and remove dist from exclude to enable some type checking, ie: it should become "exclude": ["node_modules"].
npm install and npm run build
Use that as the dependency instead, ie: "@modelcontextprotocol/sdk": "file:../typescript-sdk" in the package.json for both the server and the client we will have next!
First of all, a separate MCPServer class to make the logic management a little easier! Basically just a wrapper around the Server.

import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StreamableHTTPServerTransport } from "@modelcontextprotocol/sdk/server/streamableHttp.js";
import { Notification, CallToolRequestSchema, ListToolsRequestSchema, LoggingMessageNotification, ToolListChangedNotification, JSONRPCNotification, JSONRPCError, InitializeRequestSchema } from "@modelcontextprotocol/sdk/types.js";
import { randomUUID } from "crypto";
import { Request, Response } from "express"

const SESSION_ID_HEADER_NAME = "mcp-session-id"
const JSON_RPC = "2.0"

export class MCPServer {
    server: Server

    // to support multiple simultaneous connections
    transports: {[sessionId: string]: StreamableHTTPServerTransport} = {}

    constructor(server: Server) {
        this.server = server
    }

    async handleGetRequest(req: Request, res: Response) {
        console.log("get request received")
        // if server does not offer an SSE stream at this endpoint.
        res.status(405).set('Allow', 'POST').send('Method Not Allowed')
        return
    }

    async handlePostRequest(req: Request, res: Response) {
        const sessionId = req.headers[SESSION_ID_HEADER_NAME] as string | undefined

        console.log("post request received")
        console.log("body: ", req.body)

        let transport: StreamableHTTPServerTransport

        try {
            // reuse existing transport
            if (sessionId && this.transports[sessionId]) {
                transport = this.transports[sessionId]
                await transport.handleRequest(req, res, req.body)
                return
            }

            // create new transport
            if (!sessionId && this.isInitializeRequest(req.body)) {
                const transport = new StreamableHTTPServerTransport({
                    sessionIdGenerator: () => randomUUID(),
                    // for stateless mode:
                    // sessionIdGenerator: () => undefined
                })

                await this.server.connect(transport)
                await transport.handleRequest(req, res, req.body)

                // session ID will only be available (if in not Stateless-Mode)
                // after handling the first request
                const sessionId = transport.sessionId
                if (sessionId) {
                    this.transports[sessionId] = transport
                }

                await sendMessages(transport)
                return
            }

            res.status(400).json(this.createErrorResponse("Bad Request: invalid session ID or method."))
            return

        } catch (error) {

            console.error('Error handling MCP request:', error)
            res.status(500).json(this.createErrorResponse("Internal server error."))
            return
        }
    }

    // send message streaming message every second
    // cannot use server.sendLoggingMessage because we have can have multiple transports
    private async sendMessages(transport: StreamableHTTPServerTransport) {
         //... same as above
    }

    private createErrorResponse(message: string): JSONRPCError {
        return {
            jsonrpc: '2.0',
            error: {
              code: -32000,
              message: message,
            },
            id: randomUUID(),
        }
    }

    private isInitializeRequest(body: any): boolean {
        const isInitial = (data: any) => {
            const result = InitializeRequestSchema.safeParse(data)
            return result.success
        }
        if (Array.isArray(body)) {
          return body.some(request => isInitial(request))
        }
        return isInitial(body)
    }

}
And the API endpoints with express.

import express, { Request, Response } from "express"
import { Server } from "@modelcontextprotocol/sdk/server/index.js"
import { MCPServer } from "./server.js"

/*******************************/
/******* Server Set Up *******/
/*******************************/

const server = new MCPServer(
    new Server({
        name: "itsuki-mcp-server",
        version: "1.0.0"
    }, {
        capabilities: {}
    })
)

/*******************************/
/******* Endpoint Set Up *******/
/*******************************/

// to support multiple simultaneous connections

const app = express()
app.use(express.json())

const router = express.Router()

// endpoint for the client to use for sending messages
const MCP_ENDPOINT = "/mcp"

// handler
router.post(MCP_ENDPOINT, async (req: Request, res: Response) => {
    await server.handlePostRequest(req, res)
})

// Handle GET requests for SSE streams (using built-in support from StreamableHTTP)
router.get(MCP_ENDPOINT, async (req: Request, res: Response) => {
    await server.handleGetRequest(req, res)
})


app.use('/', router)

const PORT = 3000
app.listen(PORT, () => {
    console.log(`MCP Streamable HTTP Server listening on port ${PORT}`)
})
Before we move on, there are (already) couple differences from the SSE version (And there are more, but we won’t notice those until we test it out so let’s skip that for now).

The GET method. As I have mentioned above, we have to have a SINGLE HTTP endpoint path that supports both POST and GET methods. AND the server MUST either return Content-Type: text/event-stream in response to the HTTP GET, or else return HTTP 405 Method Not Allowed, indicating that the server does not offer an SSE stream at this endpoint. We will be adding more to this method to support standalone SSE!
There are no separate endpoints for initializing the connection. Everything is done within the POST. If the sessionId is undefined and the request body contains an InitializeRequest, ie: a JSONRPCRequest with the method being initialize, we create a new transport. Otherwise, we use the existing one!
We can also support stateless mode on the StreamableHTTPServerTransport by setting the sessionId explicitly to undefined, ie: sessionIdGenerator: () => undefined.
The sessionId passed in by the client is in the request header instead of query.
Minimized Client
When an connection with the server established by calling this.client.connect(this.transport)

import { Client } from "@modelcontextprotocol/sdk/client/index.js"
import { URL } from "url"
import { StreamableHTTPClientTransport } from "@modelcontextprotocol/sdk/client/streamableHttp.js"
import { LoggingMessageNotificationSchema, NotificationSchema, ProgressNotificationSchema, ServerNotificationSchema, ToolListChangedNotificationSchema } from "@modelcontextprotocol/sdk/types.js"

// Protocol client that maintain 1:1 connection with servers
class MCPClient {
    private client: Client
    private transport: StreamableHTTPClientTransport | null = null
    private isCompleted = false

    constructor(serverName: string) {
        this.client = new Client({ name: `mcp-client-for-${serverName}`, version: "1.0.0" })
    }

    async connectToServer(serverUrl: string) {
        const url = new URL(serverUrl)
        try {
            this.transport = new StreamableHTTPClientTransport(url)
            await this.client.connect(this.transport)
            console.log("Connected to server")

            this.setUpTransport()
        } catch (e) {
            console.log("Failed to connect to MCP server: ", e)
            throw e
        }
    }


    private setUpTransport() {
        if (this.transport === null) {
            return
        }
        this.transport.onclose = () => {
            console.log("SSE transport closed.")
            this.isCompleted = true
        }

        this.transport.onerror = async (error) => {
            console.log("SSE transport error: ", error)
            await this.cleanup()
        }

        this.transport.onmessage = (message) => {
            console.log("message received: ", message)

        };
    }

    async waitForCompletion() {
        while (!this.isCompleted) {
          await new Promise(resolve => setTimeout(resolve, 100));
        }
    }

    async cleanup() {
        await this.client.close()
    }
}

async function main() {
    const client = new MCPClient("sse-server")

    try {
        await client.connectToServer("http://localhost:3000/mcp")
        await client.waitForCompletion()
    } finally {
        await client.cleanup()
    }
}

main()
Almost the same, except changing SSEClientTransport to StreamableHTTPClientTransport. Of course, we will be adding more as we move on!

Try It Out!
Again

npm run build for both the server and the client
start the server with node path/to/server/build/index.js
start the client with node path/to/client/build/index.js
First of all, we should see something similar to the following on the server side.

post request received
body:  {
  method: 'initialize',
  params: {
    protocolVersion: '2024-11-05',
    capabilities: {},
    clientInfo: { name: 'mcp-client-for-sse-server', version: '1.0.0' }
  },
  jsonrpc: '2.0',
  id: 0
}
Stream started
post request received
body:  { method: 'notifications/initialized', jsonrpc: '2.0' }
Sent: Message 1 at 2025-04-14T02:44:05.643Z
Sent: Message 2 at 2025-04-14T02:44:06.643Z
Stream completed
Just like the SSE version, after we call client.connect on the client side, the initialize request and the notifications/initialized are POST to our server automatically!

And on the client side.

Connected to server
Yes! Only this 1 single line!

We are not receiving the streaming messages we sent from the server like we did with the SSE version!

That is because we have not open an SSE stream between client and server yet! We have set our GET endpoint to return 405!

Enable SSE Stream
So!

Next step!

Let’s see how we can support standalone SSE by implementing our GET /mcp endpoint!

async handleGetRequest(req: Request, res: Response) {
    console.log("get request received")
    // if server does not offer an SSE stream at this endpoint.
    // res.status(405).set('Allow', 'POST').send('Method Not Allowed')

    const sessionId = req.headers['mcp-session-id'] as string | undefined
    if (!sessionId || !this.transports[sessionId]) {
        res.status(400).json(this.createErrorResponse("Bad Request: invalid session ID or method."))
        return
    }

    console.log(`Establishing SSE stream for session ${sessionId}`)
    const transport = this.transports[sessionId]
    await transport.handleRequest(req, res)
    await this.streamMessages(transport)

    return
}
That’s it!

All we have here is retrieving the sessionId from the header, and call transport.handleRequest!

Rebuilt the app and try it again! We don’t have to make any changes on the client side! The client will automatically (yes, again!) try to call the GET endpoint after the connection is established.

This time, we should see the following on the client side

Connected to server
message received:  {
  jsonrpc: '2.0',
  method: 'sse/connection',
  params: { message: 'SSE Connection established' }
}
// ...
message received:  {
  jsonrpc: '2.0',
  method: 'sse/complete',
  params: { message: 'Stream completed' }
}
Add Some Dynamic Tools
A server won’t be too interesting without any capability!

Let’s add

A regular tool that returns a single response
A tool that sends multiple messages back to the client with notifications
We will also update the tool schemas dynamically every couple seconds, so that we get an idea of how we can set up notifications on the client side to watch for tools/prompts/resources changes!

Note that what we have in this section does NOT require the standalone SSE Stream, so you can still return 405 from the GET endpoint if you like!

First of all, on the server side.

export class MCPServer {

    // ... 
    private toolInterval: NodeJS.Timeout | undefined
    private singleGreetToolName = "single-greet"
    private multiGreetToolName = "multi-great"


    constructor(server: Server) {
        this.server = server
        this.setupTools()
    }

    // ...

    async cleanup() {
        this.toolInterval?.close()
        await this.server.close()
    }

    private setupTools() {

        // Define available tools
        const setToolSchema = () => this.server.setRequestHandler(ListToolsRequestSchema, async () => {
            this.singleGreetToolName = `single-greeting-${randomUUID()}`

            // tool that returns a single greeting
            const singleGreetTool = {
                name: this.singleGreetToolName,
                description: "Greet the user once.",
                inputSchema: {
                    type: "object",
                    properties: {
                        name: {
                            type: "string" ,
                            description: "name to greet"
                        },
                    },
                    required: ["name"]
                }
            }

            // tool that sends multiple greetings with notifications
            const multiGreetTool = {
                name: this.multiGreetToolName,
                description: "Greet the user multiple times with delay in between.",
                inputSchema: {
                    type: "object",
                    properties: {
                        name: {
                            type: "string" ,
                            description: "name to greet"
                        },
                    },
                    required: ["name"]
                }
            }

            return {
                tools: [singleGreetTool, multiGreetTool]
            }
        })

        setToolSchema()

        // set tools dynamically, changing 5 second
        this.toolInterval = setInterval(async () => {
            setToolSchema()
            // to notify client that the tool changed
            Object.values(this.transports).forEach((transport) => {
                const notification: ToolListChangedNotification = {
                    method: "notifications/tools/list_changed",
                }
                this.sendNotification(transport, notification)
            })
        }, 5000)

        // handle tool calls
        this.server.setRequestHandler(CallToolRequestSchema, async (request, extra) => {
            console.log("tool request received: ", request)
            console.log("extra: ", extra)

            const args = request.params.arguments
            const toolName = request.params.name
            const sendNotification = extra.sendNotification

            if (!args) {
                throw new Error("arguments undefined")
            }

            if (!toolName) {
                throw new Error("tool name undefined")
            }

            if (toolName === this.singleGreetToolName) {

                const { name } = args

                if (!name) {
                    throw new Error("Name to greet undefined.")
                }

                return {
                    content: [ {
                        type: "text",
                        text: `Hey ${name}! Welcome to itsuki's world!`
                    }]
                }
            }

            if (toolName === this.multiGreetToolName) {
                const { name } = args
                const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms))

                let notification: LoggingMessageNotification = {
                    method: "notifications/message",
                    params: { level: "info", data: `First greet to ${name}` }
                }

                await sendNotification(notification)

                await sleep(1000)

                notification.params.data = `Second greet to ${name}`
                await sendNotification(notification);

                await sleep(1000)

                return {
                    content: [ {
                        type: "text",
                        text: `Hope you enjoy your day!`
                    }]
                }
            }

            throw new Error("Tool not found")
        })
    }


    // ...

    private async sendNotification(transport: StreamableHTTPServerTransport, notification: Notification) {
        const rpcNotificaiton: JSONRPCNotification = {
            ...notification,
            jsonrpc: JSON_RPC,
        }
        await transport.send(rpcNotificaiton)
    }

    // ...

}
Two take aways here!

When we changed the tool schema, our clients that are connected to the server will NOT be automatically notified. We will have to send them a ToolListChangedNotification.
To send client messages in responding to CallToolRequest with notifications, we retrieve the sendNotification function from the extra and send LoggingMessageNotification using it. I am declaring a separate variable just to ensure the type, especially the method parameter is correct. This is really important for our client to actually receive it!
There are also couple other parameters within extra you might be interested in.

signal: AbortSignal used to communicate if the request was cancelled from the sender’s side.
sessionId?: string. The session ID from the transport if available.
sendRequest function to send a request that relates to the current request being handled.
We will also have to change the initialization code to include the capabilities.

const server = new MCPServer(
    new Server({
        name: "itsuki-mcp-server",
        version: "1.0.0"
    }, {
        capabilities: {
            tools: {},
            logging: {}
        }
    })
)
Note that in addition to tools, we will also need the logging, enabling us to send notification messages to the client.

The Client side.

import { Client } from "@modelcontextprotocol/sdk/client/index.js"
import { URL } from "url"
import { StreamableHTTPClientTransport } from "@modelcontextprotocol/sdk/client/streamableHttp.js"
import { LoggingMessageNotificationSchema, ToolListChangedNotificationSchema, TextContentSchema } from "@modelcontextprotocol/sdk/types.js"


class MCPClient {
    tools: {name: string, description: string}[] = []

    private client: Client
    private transport: StreamableHTTPClientTransport | null = null
    private isCompleted = false

    constructor(serverName: string) {
        this.client = new Client({ name: `mcp-client-for-${serverName}`, version: "1.0.0" })
    }

    async connectToServer(serverUrl: string) {
        const url = new URL(serverUrl)
        try {
            this.transport = new StreamableHTTPClientTransport(url)
            await this.client.connect(this.transport)
            console.log("Connected to server")

            this.setUpTransport()
            this.setUpNotifications()
        } catch (e) {
            console.log("Failed to connect to MCP server: ", e)
            throw e
        }
    }

    async listTools() {
        try {
            const toolsResult = await this.client.listTools()
            console.log('Available tools:', toolsResult.tools)
            this.tools = toolsResult.tools.map((tool) => {
                return {
                    name: tool.name,
                    description: tool.description ?? "",
                }
            })
        } catch (error) {
            console.log(`Tools not supported by the server (${error})`);
        }
    }

    async callTool(name: string) {
        try {
            console.log('\nCalling tool: ', name);

            const result  = await this.client.callTool({
                name: name,
                arguments: { name: "itsuki"},
            })

            const content = result.content as object[]

            console.log('results:');
            content.forEach((item) => {
                const parse = TextContentSchema.safeParse(item)
                if (parse.success) {
                    console.log(`- ${parse.data.text}`);
                }
            })
        } catch (error) {
            console.log(`Error calling greet tool: ${error}`);
        }

    }

    // Set up notification handlers for server-initiated messages
    private setUpNotifications() {
        this.client.setNotificationHandler(LoggingMessageNotificationSchema, (notification) => {
            console.log("LoggingMessageNotificationSchema received:  ", notification)
        })
        // will only be triggered after list tools called
        this.client.setNotificationHandler(ToolListChangedNotificationSchema, async (notification) => {
            console.log("ToolListChangedNotificationSchema received:  ", notification)
            await this.listTools()
        })
    }

    private setUpTransport() {
        if (this.transport === null) {
            return
        }
        this.transport.onclose = () => {
            console.log("SSE transport closed.")
            this.isCompleted = true
        }

        this.transport.onerror = async (error) => {
            console.log("SSE transport error: ", error)
            await this.cleanup()
        }
    }

    async waitForCompletion() {
        while (!this.isCompleted) {
          await new Promise(resolve => setTimeout(resolve, 100));
        }
    }

    async cleanup() {
        await this.client.close()
    }
}

async function main() {
    const client = new MCPClient("sse-server")

    try {
        await client.connectToServer("http://localhost:3000/mcp")
        await client.listTools()
        for (const tool of client.tools) {
            await client.callTool(tool.name)
        }
        await client.waitForCompletion()
    } finally {
        await client.cleanup()
    }
}

main()
Quite a bit of things I would like to mention here!

First of all, we have removed the this.transport.onmessage. It will prevent us from getting the results of listTools and callTool , as well as the invocation of the notification handlers! This change has a little side effect that requires us to make some changes on the server side but let’s skip that for now.

Secondly, we have set up two notifications here, LoggingMessageNotificationSchema for receiving notification messages, and ToolListChangedNotificationSchema for monitoring tool list change.

`private setUpNotifications() {
        this.client.setNotificationHandler(LoggingMessageNotificationSchema, (notification) => {
            console.log("LoggingMessageNotificationSchema received:  ", notification)
        })
        // will only be triggered after list tools called
        this.client.setNotificationHandler(ToolListChangedNotificationSchema, async (notification) => {
            console.log("ToolListChangedNotificationSchema received:  ", notification)
            await this.listTools()
        })
    }
Also, we have list the tools with listTools and call tools with callTool function. However, you can also do this by creating a ListToolRequest or a CallToolRequest manually and call client.request instead. Using callTool as an example, the following is equivalent to what we had above!

const request: CallToolRequest = {
  method: 'tools/call',
  params: {
    name: name,
    arguments: { name: 'itsuki' }
  }
};
const result = await this.client.request(request, CallToolResultSchema);
Let’s give it a try!

Connected to server
Available tools: [
  {
    name: 'single-greeting-569a9b7b-ea52-48d9-9a14-eefa5e8248ce',
    description: 'Greet the user once.',
    inputSchema: { type: 'object', properties: [Object], required: [Array] }
  },
  {
    name: 'multi-great',
    description: 'Greet the user multiple times with delay in between.',
    inputSchema: { type: 'object', properties: [Object], required: [Array] }
  }
]

Calling tool:  single-greeting-569a9b7b-ea52-48d9-9a14-eefa5e8248ce
results:
- Hey itsuki! Welcome to itsuki's world!

Calling tool:  multi-great
LoggingMessageNotificationSchema received:   {
  method: 'notifications/message',
  params: { level: 'info', data: 'First greet to itsuki' }
}
LoggingMessageNotificationSchema received:   {
  method: 'notifications/message',
  params: { level: 'info', data: 'Second greet to itsuki' }
}
results:
- Hope you enjoy your day!
ToolListChangedNotificationSchema received:   { method: 'notifications/tools/list_changed' }
Available tools: [
  {
    name: 'single-greeting-de6f14fa-e7f3-447e-978a-9419a1f3ee88',
    description: 'Greet the user once.',
    inputSchema: { type: 'object', properties: [Object], required: [Array] }
  },
  {
    name: 'multi-great',
    description: 'Greet the user multiple times with delay in between.',
    inputSchema: { type: 'object', properties: [Object], required: [Array] }
  }
]
Perfect!

We can list the tools, call them, receiving the notifications messages sent within the tool calls, and the tool change notification!

HOWEVER!

We are NOT receiving the messages we stream any more! Again!

The reason for that is the method we use when sending the message! In order for us to be able to receive those within the this.client.setNotificationHandler(LoggingMessageNotificationSchema…), the method has to be notifications/message like following.

transport.send({
    jsonrpc: "2.0",
    method: "notifications/message",
    params: { level: "info", data: message }
})
Of course, we don’t like hard coding those method without any checks, so there are couple better approaches!

First, if your server will only handle 1 transport at a time, that is you don’t have the transports map like we did, you can simply use server.sendLoggingMessage instead.

server.sendLoggingMessage({
    level: "info",
    data: "SSE stream opened"
})
However, this will not work if we have multiple transports, what we can do instead is to have our message conform to the LoggingMessageNotification type and use our sendNotification function instead.

const message: LoggingMessageNotification = {
    method: "notifications/message",
    params: { level: "info", data: "SSE Connection established" }
}

this.sendNotification(transport, message)
Give the server a build and try it again!

This time, we should see those streaming messages received by our client!

Thank you for making to the end of this super long article!

Again, feel free to grab the code from my GitHub!

Happy HTTP streaming!