TITLE: ModelContextProtocol Prompt Registration and Argument Completions API
DESCRIPTION: Details the API for registering prompts and enabling dynamic argument completions within the ModelContextProtocol server and client SDKs.
SOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/README.md#_snippet_10

LANGUAGE: APIDOC
CODE:
```
server.registerPrompt(name: string, config: PromptConfig, handler: PromptHandler)
  - Registers a new prompt with the server.
  - Parameters:
    - name: Unique identifier for the prompt (string).
    - config: Object containing prompt metadata.
      - title: Display name for the prompt (string, optional).
      - description: Description of the prompt (string, optional).
      - argsSchema: Zod schema defining the prompt's arguments (object).
    - handler: Function that generates messages based on prompt arguments.
      - ({ [argName: string]: any }) => { messages: Message[] }

completable(schema: ZodType, completer: (value: string, context: CompletionContext) => string[])
  - A utility function to wrap Zod schemas, enabling argument completion.
  - Parameters:
    - schema: The base Zod schema for the argument type.
    - completer: A function that returns an array of suggested completion strings.
      - value: The partial string typed by the user.
      - context: An object containing previously resolved arguments ({ arguments: { [argName: string]: any } }).

client.complete(request: CompletionRequest) => Promise<CompletionResult>
  - Requests argument completions from the server.
  - Parameters:
    - request: Object defining the completion request.
      - ref: Reference to the prompt or resource.
        - type: "ref/prompt" or "ref/resource".
        - name: Name of the prompt/resource (string).
        - uri: URI of the template (string, alternative to name).
      - argument: Details of the argument to complete.
        - name: Name of the argument (string).
        - value: The partial value typed by the user (string).
      - context: Optional object containing previously resolved arguments.
        - arguments: { [argName: string]: any }
  - Returns: A promise resolving to a CompletionResult object (e.g., { completions: string[] }).
```

----------------------------------------

TITLE: Run Streamable HTTP Client with OAuth
DESCRIPTION: An example of the Streamable HTTP client demonstrating OAuth integration. This snippet shows how to run the client with OAuth enabled.
SOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/src/examples/README.md#_snippet_1

LANGUAGE: bash
CODE:
```
npx tsx src/examples/client/simpleOAuthClient.js
```

----------------------------------------

TITLE: Run Streamable HTTP Client Example
DESCRIPTION: Demonstrates a full-featured interactive client connecting to a Streamable HTTP server. It covers connection management, tool invocation, prompt handling, resource listing, session termination, reconnection, and resumability with Last-Event-ID tracking.
SOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/src/examples/README.md#_snippet_0

LANGUAGE: bash
CODE:
```
npx tsx src/examples/client/simpleStreamableHttp.ts
```

----------------------------------------

TITLE: ModelContextProtocol Tool Registration and Metadata API
DESCRIPTION: Describes the API for registering tools and managing their display metadata within the ModelContextProtocol SDK, including title precedence rules.
SOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/README.md#_snippet_11

LANGUAGE: APIDOC
CODE:
```
server.registerTool(name: string, config: ToolConfig, handler: ToolHandler)
  - Recommended method to register a new tool with the server.
  - Parameters:
    - name: Unique identifier for the tool (string).
    - config: Object containing tool metadata.
      - title: Display name for the tool (string, optional). This takes precedence.
      - annotations: Object for additional metadata, including 'title' for backward compatibility (object, optional).
    - handler: Function that handles tool execution.

server.tool(name: string, description: string, annotations: ToolAnnotations, handler: ToolHandler)
  - Older method for registering tools, primarily for backward compatibility.
  - Parameters:
    - name: Unique identifier for the tool (string).
    - description: Description of the tool (string).
    - annotations: Object containing tool metadata, including 'title' which acts as the display name if no direct 'title' is set via registerTool.
    - handler: Function that handles tool execution.

getDisplayName(entity: { name: string, title?: string, annotations?: { title?: string } }): string
  - Utility function to retrieve the appropriate display name for a tool, prompt, or resource.
  - Parameters:
    - entity: An object representing a tool, prompt, or resource, containing at least a 'name' property, and optionally 'title' and 'annotations.title'.
  - Returns: The resolved display name based on precedence: 'title' field > 'annotations.title' > 'name'.
```

----------------------------------------

TITLE: Starting MCP Server Implementations for Backwards Compatibility Testing
DESCRIPTION: Commands to start various server implementations, including legacy SSE, Streamable HTTP, and a backwards-compatible server, for testing interoperability between different protocol versions.
SOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/src/examples/README.md#_snippet_10

LANGUAGE: bash
CODE:
```
# Legacy SSE server (protocol version 2024-11-05)
npx tsx src/examples/server/simpleSseServer.ts

# Streamable HTTP server (protocol version 2025-03-26)
npx tsx src/examples/server/simpleStreamableHttp.ts

# Backwards compatible server (supports both protocols)
npx tsx src/examples/server/sseAndStreamableHttpCompatibleServer.ts
```

----------------------------------------

TITLE: Create an MCP Echo Server with Resources, Tools, and Prompts
DESCRIPTION: Illustrates how to build a basic Model Context Protocol (MCP) server that registers an 'echo' resource, an 'echo' tool, and an 'echo' prompt. This example demonstrates the core functionalities of `McpServer` for handling different types of interactions.
SOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/README.md#_snippet_18

LANGUAGE: typescript
CODE:
```
import { McpServer, ResourceTemplate } from "@modelcontextprotocol/sdk/server/mcp.js";
import { z } from "zod";

const server = new McpServer({
  name: "echo-server",
  version: "1.0.0"
});

server.registerResource(
  "echo",
  new ResourceTemplate("echo://{message}", { list: undefined }),
  {
    title: "Echo Resource",
    description: "Echoes back messages as resources"
  },
  async (uri, { message }) => ({
    contents: [{
      uri: uri.href,
      text: `Resource echo: ${message}`
    }]
  })
);

server.registerTool(
  "echo",
  {
    title: "Echo Tool",
    description: "Echoes back the provided message",
    inputSchema: { message: z.string() }
  },
  async ({ message }) => ({
    content: [{ type: "text", text: `Tool echo: ${message}` }]
  })
);

server.registerPrompt(
  "echo",
  {
    title: "Echo Prompt",
    description: "Creates a prompt to process a message",
    argsSchema: { message: z.string() }
  },
  ({ message }) => ({
    messages: [{
      role: "user",
      content: {
        type: "text",
        text: `Please process this message: ${message}`
      }
    }]
  })
);
```

----------------------------------------

TITLE: Implement Stateless MCP Server with Express.js
DESCRIPTION: Demonstrates how to set up a stateless Model Context Protocol (MCP) server using Express.js, handling POST, GET, and DELETE requests. Each request creates new transport and server instances for isolation, suitable for simple API wrappers and horizontally scaled deployments.
SOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/README.md#_snippet_16

LANGUAGE: typescript
CODE:
```
const app = express();
app.use(express.json());

app.post('/mcp', async (req: Request, res: Response) => {
  // In stateless mode, create a new instance of transport and server for each request
  // to ensure complete isolation. A single instance would cause request ID collisions
  // when multiple clients connect concurrently.
  
  try {
    const server = getServer(); 
    const transport: StreamableHTTPServerTransport = new StreamableHTTPServerTransport({
      sessionIdGenerator: undefined,
    });
    res.on('close', () => {
      console.log('Request closed');
      transport.close();
      server.close();
    });
    await server.connect(transport);
    await transport.handleRequest(req, res, req.body);
  } catch (error) {
    console.error('Error handling MCP request:', error);
    if (!res.headersSent) {
      res.status(500).json({
        jsonrpc: '2.0',
        error: {
          code: -32603,
          message: 'Internal server error',
        },
        id: null,
      });
    }
  }
});

// SSE notifications not supported in stateless mode
app.get('/mcp', async (req: Request, res: Response) => {
  console.log('Received GET MCP request');
  res.writeHead(405).end(JSON.stringify({
    jsonrpc: "2.0",
    error: {
      code: -32000,
      message: "Method not allowed."
    },
    id: null
  }));
});

// Session termination not needed in stateless mode
app.delete('/mcp', async (req: Request, res: Response) => {
  console.log('Received DELETE MCP request');
  res.writeHead(405).end(JSON.stringify({
    jsonrpc: "2.0",
    error: {
      code: -32000,
      message: "Method not allowed."
    },
    id: null
  }));
});


// Start the server
const PORT = 3000;
setupServer().then(() => {
  app.listen(PORT, (error) => {
    if (error) {
      console.error('Failed to start server:', error);
      process.exit(1);
    }
    console.log(`MCP Stateless Streamable HTTP Server listening on port ${PORT}`);
  });
}).catch(error => {
  console.error('Failed to set up the server:', error);
  process.exit(1);
});
```

----------------------------------------

TITLE: Create a Basic MCP Server with Tool and Resource in TypeScript
DESCRIPTION: This TypeScript example demonstrates how to initialize an `McpServer`, register a simple 'add' tool with input validation using Zod, and register a dynamic 'greeting' resource. It then connects the server to a `StdioServerTransport` to handle messages via standard input/output, showcasing core server setup and functionality for exposing data and operations to LLMs.
SOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/README.md#_snippet_1

LANGUAGE: typescript
CODE:
```
import { McpServer, ResourceTemplate } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod";

// Create an MCP server
const server = new McpServer({
  name: "demo-server",
  version: "1.0.0"
});

// Add an addition tool
server.registerTool("add",
  {
    title: "Addition Tool",
    description: "Add two numbers",
    inputSchema: { a: z.number(), b: z.number() }
  },
  async ({ a, b }) => ({
    content: [{ type: "text", text: String(a + b) }]
  })
);

// Add a dynamic greeting resource
server.registerResource(
  "greeting",
  new ResourceTemplate("greeting://{name}", { list: undefined }),
  { 
    title: "Greeting Resource",      // Display name for UI
    description: "Dynamic greeting generator"
  },
  async (uri, { name }) => ({
    contents: [{
      uri: uri.href,
      text: `Hello, ${name}!`
    }]
  })
);

// Start receiving messages on stdin and sending messages on stdout
const transport = new StdioServerTransport();
await server.connect(transport);
```

----------------------------------------

TITLE: Run MCP Server with Streamable HTTP and SSE Compatibility
DESCRIPTION: This command executes the example TypeScript server that demonstrates support for both Streamable HTTP and deprecated SSE transports, adhering to the MCP specification for backwards compatibility.
SOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/src/examples/README.md#_snippet_7

LANGUAGE: bash
CODE:
```
npx tsx src/examples/server/sseAndStreamableHttpCompatibleServer.ts
```

----------------------------------------

TITLE: Registering LLM Tools with TypeScript SDK
DESCRIPTION: This snippet illustrates how to register various tools (simple calculator, external API fetcher, and a file lister returning `ResourceLinks`) using the `server.registerTool` method. Tools allow LLMs to perform computations and actions with side effects, and can return content directly or references to resources.
SOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/README.md#_snippet_3

LANGUAGE: typescript
CODE:
```
// Simple tool with parameters
server.registerTool(
  "calculate-bmi",
  {
    title: "BMI Calculator",
    description: "Calculate Body Mass Index",
    inputSchema: {
      weightKg: z.number(),
      heightM: z.number()
    }
  },
  async ({ weightKg, heightM }) => ({
    content: [{
      type: "text",
      text: String(weightKg / (heightM * heightM))
    }]
  })
);

// Async tool with external API call
server.registerTool(
  "fetch-weather",
  {
    title: "Weather Fetcher",
    description: "Get weather data for a city",
    inputSchema: { city: z.string() }
  },
  async ({ city }) => {
    const response = await fetch(`https://api.weather.com/${city}`);
    const data = await response.text();
    return {
      content: [{ type: "text", text: data }]
    };
  }
);

// Tool that returns ResourceLinks
server.registerTool(
  "list-files",
  {
    title: "List Files",
    description: "List project files",
    inputSchema: { pattern: z.string() }
  },
  async ({ pattern }) => ({
    content: [
      { type: "text", text: `Found files matching "${pattern}":` },
      // ResourceLinks let tools return references without file content
      {
        type: "resource_link",
        uri: "file:///project/README.md",
        name: "README.md",
        mimeType: "text/markdown",
        description: 'A README file'
      },
      {
        type: "resource_link",
        uri: "file:///project/src/index.ts",
        name: "index.ts",
        mimeType: "text/typescript",
        description: 'An index file'
      }
    ]
  })
);
```

----------------------------------------

TITLE: Registering LLM Resources with TypeScript SDK
DESCRIPTION: This snippet demonstrates how to register different types of resources (static, dynamic with parameters, and context-aware with completion logic) using the `server.registerResource` method. Resources are used to expose data to LLMs, similar to GET endpoints, and should not have side effects.
SOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/README.md#_snippet_2

LANGUAGE: typescript
CODE:
```
// Static resource
server.registerResource(
  "config",
  "config://app",
  {
    title: "Application Config",
    description: "Application configuration data",
    mimeType: "text/plain"
  },
  async (uri) => ({
    contents: [{
      uri: uri.href,
      text: "App configuration here"
    }]
  })
);

// Dynamic resource with parameters
server.registerResource(
  "user-profile",
  new ResourceTemplate("users://{userId}/profile", { list: undefined }),
  {
    title: "User Profile",
    description: "User profile information"
  },
  async (uri, { userId }) => ({
    contents: [{
      uri: uri.href,
      text: `Profile data for user ${userId}`
    }]
  })
);

// Resource with context-aware completion
server.registerResource(
  "repository",
  new ResourceTemplate("github://repos/{owner}/{repo}", {
    list: undefined,
    complete: {
      // Provide intelligent completions based on previously resolved parameters
      repo: (value, context) => {
        if (context?.arguments?.["owner"] === "org1") {
          return ["project1", "project2", "project3"].filter(r => r.startsWith(value));
        }
        return ["default-repo"].filter(r => r.startsWith(value));
      }
    }
  }),
  {
    title: "GitHub Repository",
    description: "Repository information"
  },
  async (uri, { owner, repo }) => ({
    contents: [{
      uri: uri.href,
      text: `Repository: ${owner}/${repo}`
    }]
  })
);
```

----------------------------------------

TITLE: Initialize and Use Model Context Protocol TypeScript Client
DESCRIPTION: Demonstrates how to initialize an MCP client using `StdioClientTransport` and perform common operations like listing prompts, getting a specific prompt, listing/reading resources, and calling tools. It shows the basic setup for interacting with an MCP server via a standard I/O transport.
SOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/README.md#_snippet_24

LANGUAGE: typescript
CODE:
```
import { Client } from "@modelcontextprotocol/sdk/client/index.js";
import { StdioClientTransport } from "@modelcontextprotocol/sdk/client/stdio.js";

const transport = new StdioClientTransport({
  command: "node",
  args: ["server.js"]
});

const client = new Client(
  {
    name: "example-client",
    version: "1.0.0"
  }
);

await client.connect(transport);

// List prompts
const prompts = await client.listPrompts();

// Get a prompt
const prompt = await client.getPrompt({
  name: "example-prompt",
  arguments: {
    arg1: "value"
  }
});

// List resources
const resources = await client.listResources();

// Read a resource
const resource = await client.readResource({
  uri: "file:///example.txt"
});

// Call a tool
const result = await client.callTool({
  name: "example-tool",
  arguments: {
    arg1: "value"
  }
});
```

----------------------------------------

TITLE: Run Backwards Compatible Client with SSE Fallback
DESCRIPTION: Implements a client that supports backwards compatibility with both new and legacy MCP servers. It first attempts a Streamable HTTP POST request and falls back to an SSE GET request if the initial attempt fails with a 4xx status.
SOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/src/examples/README.md#_snippet_2

LANGUAGE: bash
CODE:
```
npx tsx src/examples/client/streamableHttpWithSseFallbackClient.ts
```

----------------------------------------

TITLE: MCP Server SQLite Database Integration
DESCRIPTION: This TypeScript example demonstrates how to integrate a SQLite database with an MCP server. It registers a 'schema' resource to expose the database schema and a 'query' tool to execute arbitrary SQL queries, handling results and errors. It utilizes `sqlite3` for database interaction and `zod` for input schema validation.
SOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/README.md#_snippet_19

LANGUAGE: typescript
CODE:
```
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import sqlite3 from "sqlite3";
import { promisify } from "util";
import { z } from "zod";

const server = new McpServer({
  name: "sqlite-explorer",
  version: "1.0.0"
});

// Helper to create DB connection
const getDb = () => {
  const db = new sqlite3.Database("database.db");
  return {
    all: promisify<string, any[]>(db.all.bind(db)),
    close: promisify(db.close.bind(db))
  };
};

server.registerResource(
  "schema",
  "schema://main",
  {
    title: "Database Schema",
    description: "SQLite database schema",
    mimeType: "text/plain"
  },
  async (uri) => {
    const db = getDb();
    try {
      const tables = await db.all(
        "SELECT sql FROM sqlite_master WHERE type='table'"
      );
      return {
        contents: [{
          uri: uri.href,
          text: tables.map((t: {sql: string}) => t.sql).join("\n")
        }]
      };
    } finally {
      await db.close();
    }
  }
);

server.registerTool(
  "query",
  {
    title: "SQL Query",
    description: "Execute SQL queries on the database",
    inputSchema: { sql: z.string() }
  },
  async ({ sql }) => {
    const db = getDb();
    try {
      const results = await db.all(sql);
      return {
        content: [{
          type: "text",
          text: JSON.stringify(results, null, 2)
        }]
      };
    } catch (err: unknown) {
      const error = err as Error;
      return {
        content: [{
          type: "text",
          text: `Error: ${error.message}`
        }],
        isError: true
      };
    } finally {
      await db.close();
    }
  }
);
```

----------------------------------------

TITLE: Connecting TypeScript MCP Server to Stdio Transport
DESCRIPTION: This example shows how to establish communication for an MCP server in TypeScript using `StdioServerTransport`. It's suitable for command-line tools and direct integrations, demonstrating the basic setup and connection process for server-client communication.
SOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/README.md#_snippet_13

LANGUAGE: typescript
CODE:
```
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";

const server = new McpServer({
  name: "example-server",
  version: "1.0.0"
});

// ... set up server resources, tools, and prompts ...

const transport = new StdioServerTransport();
await server.connect(transport);
```

----------------------------------------

TITLE: Configure Streamable HTTP Transport for Stateless Mode
DESCRIPTION: This TypeScript configuration snippet shows how to disable session management for the StreamableHTTPServerTransport by setting sessionIdGenerator to undefined. This is ideal for simple API proxies where each request is independent and no state needs to be preserved.
SOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/src/examples/README.md#_snippet_8

LANGUAGE: typescript
CODE:
```
sessionIdGenerator: undefined
```

----------------------------------------

TITLE: Defining Tool Titles with Older `tool` API and Annotations
DESCRIPTION: Illustrates how to define a tool's title using the older `server.tool` method with annotations. In this case, `annotations.title` is used as the display name if no direct `title` field is present via `registerTool`.
SOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/README.md#_snippet_8

LANGUAGE: typescript
CODE:
```
// Using tool with annotations (older API)
server.tool("my_tool", "description", {
  title: "Annotation Title"      // This is used as title
}, handler);
```

----------------------------------------

TITLE: Implementing MCP Session Management with Express.js
DESCRIPTION: This snippet demonstrates how to set up an Express.js server to handle Model Context Protocol (MCP) communication with session management. It shows how to reuse existing sessions or initialize new ones using `StreamableHTTPServerTransport` and `McpServer`, handling POST, GET, and DELETE requests for MCP interactions.
SOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/README.md#_snippet_14

LANGUAGE: typescript
CODE:
```
import express from "express";
import { randomUUID } from "node:crypto";
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StreamableHTTPServerTransport } from "@modelcontextprotocol/sdk/server/streamableHttp.js";
import { isInitializeRequest } from "@modelcontextprotocol/sdk/types.js"



const app = express();
app.use(express.json());

// Map to store transports by session ID
const transports: { [sessionId: string]: StreamableHTTPServerTransport } = {};

// Handle POST requests for client-to-server communication
app.post('/mcp', async (req, res) => {
  // Check for existing session ID
  const sessionId = req.headers['mcp-session-id'] as string | undefined;
  let transport: StreamableHTTPServerTransport;

  if (sessionId && transports[sessionId]) {
    // Reuse existing transport
    transport = transports[sessionId];
  } else if (!sessionId && isInitializeRequest(req.body)) {
    // New initialization request
    transport = new StreamableHTTPServerTransport({
      sessionIdGenerator: () => randomUUID(),
      onsessioninitialized: (sessionId) => {
        // Store the transport by session ID
        transports[sessionId] = transport;
      },
      // DNS rebinding protection is disabled by default for backwards compatibility. If you are running this server
      // locally, make sure to set:
      // enableDnsRebindingProtection: true,
      // allowedHosts: ['127.0.0.1'],
    });

    // Clean up transport when closed
    transport.onclose = () => {
      if (transport.sessionId) {
        delete transports[transport.sessionId];
      }
    };
    const server = new McpServer({
      name: "example-server",
      version: "1.0.0"
    });

    // ... set up server resources, tools, and prompts ...

    // Connect to the MCP server
    await server.connect(transport);
  } else {
    // Invalid request
    res.status(400).json({
      jsonrpc: '2.0',
      error: {
        code: -32000,
        message: 'Bad Request: No valid session ID provided',
      },
      id: null,
    });
    return;
  }

  // Handle the request
  await transport.handleRequest(req, res, req.body);
});

// Reusable handler for GET and DELETE requests
const handleSessionRequest = async (req: express.Request, res: express.Response) => {
  const sessionId = req.headers['mcp-session-id'] as string | undefined;
  if (!sessionId || !transports[sessionId]) {
    res.status(400).send('Invalid or missing session ID');
    return;
  }
  
  const transport = transports[sessionId];
  await transport.handleRequest(req, res);
};

// Handle GET requests for server-to-client notifications via SSE
app.get('/mcp', handleSessionRequest);

// Handle DELETE requests for session termination
app.delete('/mcp', handleSessionRequest);

app.listen(3000);
```

----------------------------------------

TITLE: Express.js Server with Streamable HTTP and SSE Transports
DESCRIPTION: This TypeScript Express.js example demonstrates how to create an MCP server that supports both modern Streamable HTTP and legacy SSE clients. It initializes an `McpServer`, sets up Express routes for `/mcp` (Streamable HTTP), `/sse` (SSE connection), and `/messages` (SSE message handling), managing transport instances per session.
SOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/README.md#_snippet_27

LANGUAGE: typescript
CODE:
```
import express from "express";
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StreamableHTTPServerTransport } from "@modelcontextprotocol/sdk/server/streamableHttp.js";
import { SSEServerTransport } from "@modelcontextprotocol/sdk/server/sse.js";

const server = new McpServer({
  name: "backwards-compatible-server",
  version: "1.0.0"
});

// ... set up server resources, tools, and prompts ...

const app = express();
app.use(express.json());

// Store transports for each session type
const transports = {
  streamable: {} as Record<string, StreamableHTTPServerTransport>,
  sse: {} as Record<string, SSEServerTransport>
};

// Modern Streamable HTTP endpoint
app.all('/mcp', async (req, res) => {
  // Handle Streamable HTTP transport for modern clients
  // Implementation as shown in the "With Session Management" example
  // ...
});

// Legacy SSE endpoint for older clients
app.get('/sse', async (req, res) => {
  // Create SSE transport for legacy clients
  const transport = new SSEServerTransport('/messages', res);
  transports.sse[transport.sessionId] = transport;
  
  res.on("close", () => {
    delete transports.sse[transport.sessionId];
  });
  
  await server.connect(transport);
});

// Legacy message endpoint for older clients
app.post('/messages', async (req, res) => {
  const sessionId = req.query.sessionId as string;
  const transport = transports.sse[sessionId];
  if (transport) {
    await transport.handlePostMessage(req, res, req.body);
  } else {
    res.status(400).send('No transport found for sessionId');
  }
});

app.listen(3000);
```

----------------------------------------

TITLE: Initialize and Handle Requests with MCP TypeScript Server
DESCRIPTION: This snippet demonstrates how to set up a low-level MCP server using the `@modelcontextprotocol/sdk`. It shows how to define server capabilities, register request handlers for `ListPromptsRequestSchema` and `GetPromptRequestSchema`, and connect the server via `StdioServerTransport`. This allows the server to respond to prompt-related requests from a client.
SOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/README.md#_snippet_21

LANGUAGE: typescript
CODE:
```
import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import {
  ListPromptsRequestSchema,
  GetPromptRequestSchema
} from "@modelcontextprotocol/sdk/types.js";

const server = new Server(
  {
    name: "example-server",
    version: "1.0.0"
  },
  {
    capabilities: {
      prompts: {}
    }
  }
);

server.setRequestHandler(ListPromptsRequestSchema, async () => {
  return {
    prompts: [{
      name: "example-prompt",
      description: "An example prompt template",
      arguments: [{
        name: "arg1",
        description: "Example argument",
        required: true
      }]
    }]
  };
});

server.setRequestHandler(GetPromptRequestSchema, async (request) => {
  if (request.params.name !== "example-prompt") {
    throw new Error("Unknown prompt");
  }
  return {
    description: "Example prompt",
    messages: [{
      role: "user",
      content: {
        type: "text",
        text: "Example prompt text"
      }
    }]
  };
});

const transport = new StdioServerTransport();
await server.connect(transport);
```

----------------------------------------

TITLE: Run Streamable HTTP Server with Dynamic Notifications
DESCRIPTION: Illustrates an MCP server that sends server notifications using Streamable HTTP. This includes resource list change notifications with dynamically added resources and automatic resource creation on a timed interval.
SOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/src/examples/README.md#_snippet_5

LANGUAGE: bash
CODE:
```
npx tsx src/examples/server/standaloneSseWithGetStreamableHttp.ts
```

----------------------------------------

TITLE: Registering LLM Sampling Tool with TypeScript MCP Server
DESCRIPTION: This snippet demonstrates how to register a tool with an MCP server in TypeScript that leverages LLM sampling. It sets up an `McpServer`, defines a 'summarize' tool with a Zod schema, and shows how to use `mcpServer.server.createMessage` to interact with an LLM for text summarization.
SOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/README.md#_snippet_12

LANGUAGE: typescript
CODE:
```
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod";

const mcpServer = new McpServer({
  name: "tools-with-sample-server",
  version: "1.0.0",
});

// Tool that uses LLM sampling to summarize any text
mcpServer.registerTool(
  "summarize",
  {
    description: "Summarize any text using an LLM",
    inputSchema: {
      text: z.string().describe("Text to summarize"),
    },
  },
  async ({ text }) => {
    // Call the LLM through MCP sampling
    const response = await mcpServer.server.createMessage({
      messages: [
        {
          role: "user",
          content: {
            type: "text",
            text: `Please summarize the following text concisely:\n\n${text}`,
          },
        },
      ],
      maxTokens: 500,
    });

    return {
      content: [
        {
          type: "text",
          text: response.content.type === "text" ? response.content.text : "Unable to generate summary",
        },
      ],
    };
  }
);

async function main() {
  const transport = new StdioServerTransport();
  await mcpServer.connect(transport);
  console.log("MCP server is running...");
}

main().catch((error) => {
  console.error("Server error:", error);
  process.exit(1);
});
```

----------------------------------------

TITLE: Run Simple Streamable HTTP Server with Express
DESCRIPTION: Sets up a basic MCP server using Express and the Streamable HTTP transport (protocol version 2025-03-26). It includes session management, tool and prompt implementations, static resource exposure, SSE notifications, and session termination via DELETE requests.
SOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/src/examples/README.md#_snippet_3

LANGUAGE: bash
CODE:
```
npx tsx src/examples/server/simpleStreamableHttp.ts
```

LANGUAGE: bash
CODE:
```
npx tsx src/examples/server/simpleStreamableHttp.ts --oauth
```

LANGUAGE: bash
CODE:
```
npx tsx src/examples/server/simpleStreamableHttp.ts --oauth --oauth-strict
```

----------------------------------------

TITLE: Execute Build and Test Commands for TypeScript SDK
DESCRIPTION: This snippet provides essential shell commands for managing the TypeScript SDK project, including building the application, running code linting, executing all tests, and running specific tests by file path or name pattern.
SOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/CLAUDE.md#_snippet_0

LANGUAGE: sh
CODE:
```
npm run build        # Build ESM and CJS versions
npm run lint         # Run ESLint
npm test             # Run all tests
npx jest path/to/file.test.ts  # Run specific test file
npx jest -t "test name"        # Run tests matching pattern
```

----------------------------------------

TITLE: Handle Client-Side Elicitation Requests in MCP
DESCRIPTION: This snippet provides a placeholder for client-side implementation to handle elicitation requests from an MCP server. It shows how a client should register a request handler for `ElicitRequestSchema` to display a message and collect user input based on a provided schema, then return the user's action and content back to the server. This is crucial for interactive server-client communication.
SOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/README.md#_snippet_23

LANGUAGE: typescript
CODE:
```
// This is a placeholder - implement based on your UI framework
async function getInputFromUser(message: string, schema: any): Promise<{
  action: "accept" | "decline" | "cancel";
  data?: Record<string, any>;
}> {
  // This should be implemented depending on the app
  throw new Error("getInputFromUser must be implemented for your platform");
}

client.setRequestHandler(ElicitRequestSchema, async (request) => {
  const userResponse = await getInputFromUser(
    request.params.message, 
    request.params.requestedSchema
  );
  
  return {
    action: userResponse.action,
    content: userResponse.action === "accept" ? userResponse.data : undefined
  };
});
```

----------------------------------------

TITLE: Requesting Argument Completions from the Client
DESCRIPTION: Shows how a client can request argument completions for a prompt or resource using `client.complete`. It specifies the reference type, name, the argument name, partial value, and optional context for dynamic suggestions.
SOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/README.md#_snippet_6

LANGUAGE: typescript
CODE:
```
// Request completions for any argument
const result = await client.complete({
  ref: {
    type: "ref/prompt",  // or "ref/resource"
    name: "example"      // or uri: "template://..."
  },
  argument: {
    name: "argumentName",
    value: "partial"     // What the user has typed so far
  },
  context: {             // Optional: Include previously resolved arguments
    arguments: {
      previousArg: "value"
    }
  }
});
```

----------------------------------------

TITLE: Implement Server-Side User Input Elicitation in MCP
DESCRIPTION: This code illustrates how an MCP server can elicit additional information from a user within a tool function. It uses `server.server.elicitInput` to prompt the user with a message and a JSON schema for the expected input, such as checking for alternative dates in a restaurant booking scenario. This enables interactive workflows where the server needs dynamic user confirmation or data.
SOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/README.md#_snippet_22

LANGUAGE: typescript
CODE:
```
// Server-side: Restaurant booking tool that asks for alternatives
server.tool(
  "book-restaurant",
  { 
    restaurant: z.string(),
    date: z.string(),
    partySize: z.number()
  },
  async ({ restaurant, date, partySize }) => {
    // Check availability
    const available = await checkAvailability(restaurant, date, partySize);
    
    if (!available) {
      // Ask user if they want to try alternative dates
      const result = await server.server.elicitInput({
        message: `No tables available at ${restaurant} on ${date}. Would you like to check alternative dates?`,
        requestedSchema: {
          type: "object",
          properties: {
            checkAlternatives: {
              type: "boolean",
              title: "Check alternative dates",
              description: "Would you like me to check other dates?"
            },
            flexibleDates: {
              type: "string",
              title: "Date flexibility",
              description: "How flexible are your dates?",
              enum: ["next_day", "same_week", "next_week"],
              enumNames: ["Next day", "Same week", "Next week"]
            }
          },
          required: ["checkAlternatives"]
        }
      });

      if (result.action === "accept" && result.content?.checkAlternatives) {
        const alternatives = await findAlternatives(
          restaurant, 
          date, 
          partySize, 
          result.content.flexibleDates as string
        );
        return {
          content: [{
            type: "text",
            text: `Found these alternatives: ${alternatives.join(", ")}`
          }]
        };
      }
      
      return {
        content: [{
          type: "text",
          text: "No booking made. Original date not available."
        }]
      };
    }
    
    // Book the table
    await makeBooking(restaurant, date, partySize);
    return {
      content: [{
        type: "text",
        text: `Booked table for ${partySize} at ${restaurant} on ${date}`
      }]
    };
  }
);
```

----------------------------------------

TITLE: Running Backwards Compatible MCP Client
DESCRIPTION: Command to run a client that supports both SSE and Streamable HTTP protocols, demonstrating interoperability with different server versions.
SOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/src/examples/README.md#_snippet_11

LANGUAGE: bash
CODE:
```
npx tsx src/examples/client/streamableHttpWithSseFallbackClient.ts
```

----------------------------------------

TITLE: Run Streamable HTTP Server with JSON Response Mode
DESCRIPTION: Demonstrates an MCP server using Streamable HTTP transport with JSON response mode enabled, disabling SSE. It highlights proper response handling for servers without SSE support and returning appropriate HTTP status codes for unsupported methods.
SOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/src/examples/README.md#_snippet_4

LANGUAGE: bash
CODE:
```
npx tsx src/examples/server/jsonResponseStreamableHttp.ts
```

----------------------------------------

TITLE: Registering a Basic Prompt with ModelContextProtocol
DESCRIPTION: Demonstrates how to register a simple prompt named 'review-code' using `server.registerPrompt`. It defines a title, description, and an `argsSchema` for a 'code' argument, returning a basic user message for an LLM.
SOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/README.md#_snippet_4

LANGUAGE: typescript
CODE:
```
import { completable } from "@modelcontextprotocol/sdk/server/completable.js";

server.registerPrompt(
  "review-code",
  {
    title: "Code Review",
    description: "Review code for best practices and potential issues",
    argsSchema: { code: z.string() }
  },
  ({ code }) => ({
    messages: [{
      role: "user",
      content: {
        type: "text",
        text: `Please review this code:\n\n${code}`
      }
    }]
  })
);
```

----------------------------------------

TITLE: Configure Transport for Persistent Storage Mode
DESCRIPTION: This TypeScript configuration demonstrates how to enable session management with persistent storage. By providing a sessionIdGenerator and an eventStore backed by a database, session data is externalized, allowing any server node to handle requests for the same session.
SOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/src/examples/README.md#_snippet_9

LANGUAGE: typescript
CODE:
```
sessionIdGenerator: () => randomUUID(),
eventStore: databaseEventStore
```

----------------------------------------

TITLE: Registering a Prompt with Context-Aware Argument Completions
DESCRIPTION: Illustrates registering a prompt named 'team-greeting' that uses `completable` for dynamic argument suggestions. It shows how to provide suggestions for 'department' and 'name', where 'name' suggestions depend on the selected 'department' from the `context`.
SOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/README.md#_snippet_5

LANGUAGE: typescript
CODE:
```
server.registerPrompt(
  "team-greeting",
  {
    title: "Team Greeting",
    description: "Generate a greeting for team members",
    argsSchema: {
      department: completable(z.string(), (value) => {
        // Department suggestions
        return ["engineering", "sales", "marketing", "support"].filter(d => d.startsWith(value));
      }),
      name: completable(z.string(), (value, context) => {
        // Name suggestions based on selected department
        const department = context?.arguments?.["department"];
        if (department === "engineering") {
          return ["Alice", "Bob", "Charlie"].filter(n => n.startsWith(value));
        } else if (department === "sales") {
          return ["David", "Eve", "Frank"].filter(n => n.startsWith(value));
        } else if (department === "marketing") {
          return ["Grace", "Henry", "Iris"].filter(n => n.startsWith(value));
        }
        return ["Guest"].filter(n => n.startsWith(value));
      })
    }
  },
  ({ department, name }) => ({
    messages: [{
      role: "assistant",
      content: {
        type: "text",
        text: `Hello ${name}, welcome to the ${department} team!`
      }
    }]
  })
);
```

----------------------------------------

TITLE: Dynamic Tool Management in MCP Server
DESCRIPTION: This TypeScript code illustrates how to dynamically manage tools on an MCP server. It shows how to enable, disable, update, and remove tools after the server has connected, allowing for adaptive behavior based on user actions or external state changes, such as authentication upgrades. This ensures `listChanged` notifications are automatically emitted.
SOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/README.md#_snippet_20

LANGUAGE: typescript
CODE:
```
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { z } from "zod";

const server = new McpServer({
  name: "Dynamic Example",
  version: "1.0.0"
});

const listMessageTool = server.tool(
  "listMessages",
  { channel: z.string() },
  async ({ channel }) => ({
    content: [{ type: "text", text: await listMessages(channel) }]
  })
);

const putMessageTool = server.tool(
  "putMessage",
  { channel: z.string(), message: z.string() },
  async ({ channel, message }) => ({
    content: [{ type: "text", text: await putMessage(channel, string) }]
  })
);
// Until we upgrade auth, `putMessage` is disabled (won't show up in listTools)
putMessageTool.disable()

const upgradeAuthTool = server.tool(
  "upgradeAuth",
  { permission: z.enum(["write', admin"])},
  // Any mutations here will automatically emit `listChanged` notifications
  async ({ permission }) => {
    const { ok, err, previous } = await upgradeAuthAndStoreToken(permission)
    if (!ok) return {content: [{ type: "text", text: `Error: ${err}` }]}

    // If we previously had read-only access, 'putMessage' is now available
    if (previous === "read") {
      putMessageTool.enable()
    }

    if (permission === 'write') {
      // If we've just upgraded to 'write' permissions, we can still call 'upgradeAuth' 
      // but can only upgrade to 'admin'. 
      upgradeAuthTool.update({
        paramSchema: { permission: z.enum(["admin"]) }, // change validation rules
      })
    } else {
      // If we're now an admin, we no longer have anywhere to upgrade to, so fully remove that tool
      upgradeAuthTool.remove()
    }
  }
)

// Connect as normal
const transport = new StdioServerTransport();
await server.connect(transport);
```

----------------------------------------

TITLE: Run Deprecated HTTP+SSE Transport Server
DESCRIPTION: Implements a server using the deprecated HTTP+SSE transport (protocol version 2024-11-05), primarily for backwards compatibility testing. It features separate endpoints for SSE streams and client messages, and a tool for sending periodic notifications.
SOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/src/examples/README.md#_snippet_6

LANGUAGE: bash
CODE:
```
npx tsx src/examples/server/simpleSseServer.ts
```

----------------------------------------

TITLE: Configure OAuth Proxy for Model Context Protocol Server
DESCRIPTION: Illustrates how to set up an Express application to proxy OAuth authorization requests to an external provider using `ProxyOAuthServerProvider`. This configuration allows for custom token validation and client management logic, integrating with the MCP authentication router to delegate authentication to an external service.
SOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/README.md#_snippet_25

LANGUAGE: typescript
CODE:
```
import express from 'express';
import { ProxyOAuthServerProvider } from '@modelcontextprotocol/sdk/server/auth/providers/proxyProvider.js';
import { mcpAuthRouter } from '@modelcontextprotocol/sdk/server/auth/router.js';

const app = express();

const proxyProvider = new ProxyOAuthServerProvider({
    endpoints: {
        authorizationUrl: "https://auth.external.com/oauth2/v1/authorize",
        tokenUrl: "https://auth.external.com/oauth2/v1/token",
        revocationUrl: "https://auth.external.com/oauth2/v1/revoke"
    },
    verifyAccessToken: async (token) => {
        return {
            token,
            clientId: "123",
            scopes: ["openid", "email", "profile"]
        }
    },
    getClient: async (client_id) => {
        return {
            client_id,
            redirect_uris: ["http://localhost:3000/callback"]
        }
    }
})

app.use(mcpAuthRouter({
    provider: proxyProvider,
    issuerUrl: new URL("http://auth.external.com"),
    baseUrl: new URL("http://mcp.example.com"),
    serviceDocumentationUrl: new URL("https://docs.example.com/")
}))
```

----------------------------------------

TITLE: Implement Client-Side Backwards Compatibility for MCP Transports
DESCRIPTION: Shows how an MCP client can attempt to connect using the `StreamableHTTPClientTransport` and gracefully fall back to the older `SSEClientTransport` if the initial connection fails. This pattern ensures compatibility with both newer Streamable HTTP servers and older HTTP+SSE servers, providing robust client connectivity.
SOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/README.md#_snippet_26

LANGUAGE: typescript
CODE:
```
import { Client } from "@modelcontextprotocol/sdk/client/index.js";
import { StreamableHTTPClientTransport } from "@modelcontextprotocol/sdk/client/streamableHttp.js";
import { SSEClientTransport } from "@modelcontextprotocol/sdk/client/sse.js";
let client: Client|undefined = undefined;
const baseUrl = new URL(url);
try {
  client = new Client({
    name: 'streamable-http-client',
    version: '1.0.0'
  });
  const transport = new StreamableHTTPClientTransport(
    new URL(baseUrl)
  );
  await client.connect(transport);
  console.log("Connected using Streamable HTTP transport");
} catch (error) {
  // If that fails with a 4xx error, try the older SSE transport
  console.log("Streamable HTTP connection failed, falling back to SSE transport");
  client = new Client({
    name: 'sse-client',
    version: '1.0.0'
  });
  const sseTransport = new SSEClientTransport(baseUrl);
  await client.connect(sseTransport);
  console.log("Connected using SSE transport");
}
```

----------------------------------------

TITLE: Defining Tool Titles with `registerTool` (Recommended)
DESCRIPTION: Demonstrates the recommended way to register a tool using `server.registerTool` and set its display title. It highlights that the `title` field in the configuration takes precedence over `annotations.title`.
SOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/README.md#_snippet_7

LANGUAGE: typescript
CODE:
```
// Using registerTool (recommended)
server.registerTool("my_tool", {
  title: "My Tool",              // This title takes precedence
  annotations: {
    title: "Annotation Title"    // This is ignored if title is set
  }
}, handler);
```

----------------------------------------

TITLE: Retrieving Display Names for Tools/Resources
DESCRIPTION: Shows how to use the `getDisplayName` utility from `@modelcontextprotocol/sdk/shared/metadataUtils.js` to automatically resolve the correct display name for a tool or resource, respecting the defined precedence rules (`title` field > `annotations.title` > `name`).
SOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/README.md#_snippet_9

LANGUAGE: typescript
CODE:
```
import { getDisplayName } from "@modelcontextprotocol/sdk/shared/metadataUtils.js";

// Automatically handles the precedence: title → annotations.title → name
const displayName = getDisplayName(tool);
```